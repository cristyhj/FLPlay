module.exports = Storage

function Storage () {
  this.maxMemory = 50; // 100 MB
  if (!(this instanceof Storage)) return new Storage()
  this.chunks = []
  this.passes = 0
}

Storage.prototype.clearAll = function () {
  this.chunks = []
}
Storage.prototype.clearSelection = function (start, end) {
  for (var i = start; i < end; i++) {
    this.chunks[i] = null
  }
}

Storage.prototype.getLastGetIndex = function () {
  return this.passes
}

Storage.prototype.put = function (index, buf, cb) {
  this.chunks[index] = buf

  if (cb) process.nextTick(cb)
}

Storage.prototype.memory = function () {
  var sum = 0;
  this.chunks.forEach(chunk => {
    if (chunk) sum += 1
  })
  return sum;
}

Storage.prototype.getPiecesString = function () {
  var str = '(' + this.passes + ')('
  for (var i = 0; i < this.chunks.length; i++) {
    if (this.chunks[i]) str += i + ', '
  }
  str += ')'
  return str
}

function nextTick (cb, err, val) {
  process.nextTick(function () {
    cb(err, val)
  })
}

Storage.prototype.get = function (index, opts, cb) {
  if (typeof opts === 'function') return this.get(index, null, opts)
  var buf = this.chunks[index]
  this.passes = index
  this.chunks[index] = null // garbage collect this to free memory
  if (!buf) return nextTick(cb, new Error('Chunk not found'))
  if (!opts) return nextTick(cb, null, buf)
  var offset = opts.offset || 0
  var len = opts.length || (buf.length - offset)

  nextTick(cb, null, buf.slice(offset, len + offset))
}
